# NOTE: requires starting R with
#	R --max-ppsize=500000
# to be able to make linear models.
#
# libraries to manipulate formulas
library(tools)
library(rlang)
# libraries for variable reduction
library(caret)
library(randomForest)
library(xgboost)
library(relaimpo)
library(earth)
library(Boruta)
library(rFerns)
library(randomForest)
library(DALEX)
library(vita)
library(glmnet)
# libraries for factor analysis
library(corrplot)
library(factoextra)
library(ctv)
library(psych)
library(psychTools)
library(nFactors)

# the next ones are no longer maintained and do not work, do not use
# library(devtools)
#    install_github("tomasgreif/woe")
#    install_github("tomasgreif/riv")
# library(woe)
# library(riv)

SEED <- 20240429


# create dir to save the results
dir.create('impgenes', showWarning=FALSE)

# whether we want to test the functions in this file
test_gene_imp <- TRUE

if (F) {
    #
    # Load the data
    #
    file_names <- c("signif_sorted_PFU:_wt_x_pfu000.1.tab",  #coturnix
			    "signif_sorted_PFU:_wt_x_pfu001.0.tab", 
                "signif_sorted_PFU:_wt_x_pfu010.0.tab", 
                "signif_sorted_PFU:_wt_x_pfu100.0.tab")
    #gallus
    file_names <- c('signif_sorted_sample:_DF1_x_DF1.I.tab', 
			    'signif_sorted_sample:_DF1_x_DF1.P.tab',
                'signif_sorted_sample:_DF1_x_DF1.P.I.tab',
                'signif_sorted_sample:_DF1_x_DF1.PC.tab',
                'signif_sorted_sample:_DF1_x_DF1.PC.I.tab')


    data_list <- list()

    for (file in file_names) {
    file_data <- read.table(file, header=TRUE)
    data <-  data.frame(gene = rownames(file_data), l2fc=file_data$log2FoldChange)

    #name <- sub(".*_wt", "wt", file)
    #name <- sub(".tab", "_l2fc", name)
    name <- sub(".*_DF1_", "DF1_", file)
    name <- sub(".tab", "_l2fc", name)
    colnames(data) <- c("gene", name)
    data_list[[file]] <- data
    }

    combined_data <- data_list[[1]] 
    for (i in 2:length(data_list)) {
    combined_data <- merge(combined_data, data_list[[i]], by="gene", all = TRUE)
    print(head(combined_data))
    }

    rownames(combined_data) <- combined_data$rows
    head(combined_data)

    #all_log2FC <- write.table (combined_data)
    #write.table(combined_data, file = "all_log2FC.tab", sep = "\t", quote = FALSE, row.names = TRUE)

    write.table(combined_data, file = "all_log2FC.txt", 
		    sep = "\t", 
            quote = FALSE, 
            row.names=F, col.names=T)

    # Load log2FC of significantly altered genes:
    #df <- read.table("data/coturnix/rnaseq-test/both_ends/DESeq2/signif/all_log2FC_transpose.txt",header=T)
    df <- read.table("all_log2FC.txt", header=T)
    fd <- t(combined_data)
    fd <- t(df)
    fd <- read.table("all_log2FC_transpose.txt",header=T)

    ### COTURNIX
    # set name of first column
    names(fd)[1] <- 'wt.vs.PFU'
    fd[,1] <- c(0.1, 1.0, 10.0, 100.0)
    # define working data sets
    dat <- fd[ , colSums(is.na(fd))==0]			# drop columns with NAs
    clfc <- as.data.frame(rbind(rep(0,dim(dat)[2]),dat))

    ### GALLUS
    colnames(fd) <- fd[1,]
    fd <- fd[-1,]
    rownames(fd) <- NULL

    dat <- fd[ , colSums(is.na(fd))==0]
    clfc <- as.data.frame(rbind(rep(0,dim(dat)[2]),dat)) 

    col <- c("WT","WT.I", "P", "P.I", "PC", "PC.I")
    clfc <- cbind("wt.vs.sample" = col, clfc)

    write.table(clfc, file = "all_log2FC_datz.txt", 
		    sep = "\t", 
            quote = FALSE, 
            row.names=F, col.names=T)
}

##########################################################################################################
##########################################################################################################
##########################################################################################################
##########################################################################################################

# These are some convenience functions to help with printing messages, loading libraries and plotting

#' myname()
#'
#' myname() obtains the name of the function that called it
#'
#' This function will return the name of the calling function.
#' The CALLING function !!!
#' THE CALLING FUNCTION !!!!!!
#' It is intended as a way to obtain a function's own name for error
#' reporting. 
#  We could do it directly, within a function using 
#  myname <- deparse(sys.call())
#  but it would be difficult to understand. Isolating this in a function
#  call makes it more readable.
#'
#' 
#' @return	the name of the calling function (one up in the call stack)
#'
#' @usage	me <- myname()
#'
#' @examples
#'	f <- function() { print(myname()) }
#'	f()
#'	##[1] "print(myname())"
#'	## myname() is being passed to print() as an argument and is thus
#'	## called by 'print', hence the output
#'	##
#'	f <- function() { me <- myname() ; print(me) }
#'	f()
#'	##[1] "f()"
#'	## myname() is called by f() to obtain its own name and then the name
#'	## is handled to print().
#'
#' @author	(C) CNB-CSIC
#'
#' @license	EU-GPL
#'
#' @export
#
myname <- function() { 
    calls <- deparse(sys.calls())
    me <- sys.nframe()
    my.parent <- me - 1
    who.called.me <- calls[[ my.parent ]] 
    return( who.called.me )
}


mycaller() {
    calls <- deparse(sys.calls())
    me <- sys.nframe()
    my.parent <- me - 2
    who.called.me <- calls[[ my.parent ]] 
    return( who.called.me )
}


#' cat.err()
#'
#' err() prints a generic error message using cat()
#'
#' @param	abort	(boolean) whether the program should be stopped
#'			(defaults to FALSE)
#' @param	...	The message to print and cat options (see cat())
#'
#' @return	whatever cat() returns
#'
#' @usage	cat.err('some message\n', sep='')
#'
#' @examples
#'		f <- function(x) { if (x < 10) {print(x)} else {cat.err(x, "is too big\n")}}
#'		f(13)
#'		##ERROR in  f(13) : 13 is too big
#'
#' @author	(C) CNB-CSIC
#'
#' @license	EU-GPL
#'
#' @export
#
cat.err <- function(abort=FALSE, ...) { 
    # error messages should be always printed

    # caller <- mycaller()
    #caller <- deparse( sys.calls()[[sys.nframe()-1]] )
    caller <- deparse( sys.call(-1) )
    cat('ERROR in ', caller, ":", ...)
    if (abort) {
        quit(save="no", status=1, runLast=FALSE)
    }
}


#' cat.warn()
#'
#' cat.warn() prints a generic warning message using cat()
#'
#' @param	...	The message to print and cat options (see cat())
#'
#' @return	whatever cat() returns
#'
#' @usage	cat.warn('some message\n', sep='')
#'
#' @examples
#'		f <- function(x) { if (x < 10) {print(x)} else {cat.warn(x, "is too big\n")}}
#'		f(13)
#'		##WARNING in  f(13) : 13 is too big
#'
#' @author	(C) CNB-CSIC
#'
#' @license	EU-GPL
#'
#' @export
#
cat.warn <- function(...) { 
    #caller <- deparse( sys.calls()[[sys.nframe()-1]] )
    #me <- as.list(sys.call())[[1]]
    #parent <- as.list(sys.call(-1))[[1]]
    caller <- deparse( sys.call(-1) )
    cat('WARNING in ', caller, ":", ...)
}


#' cat.info()
#'
#' cat.info() prints a generic information message using cat()
#'
#' @param	...	The message to print and cat options (see cat())
#'
#' @return	whatever cat() returns
#'
#' @usage	cat.warn('some message\n', sep='')
#'
#' @examples
#'		f <- function(x) { if (x < 10) {print(x)} else {cat.info(x, "is too big\n")}}
#'		f(13)
#'		##INFO  f(13) : 13 is too big
#'
#' @author	(C) CNB-CSIC
#'
#' @license	EU-GPL
#'
#' @export
#

cat.info <- function(...) { 
    #caller <- deparse( sys.calls()[[sys.nframe()-1]] )
    #me <- as.list(sys.call())[[1]]
    #parent <- as.list(sys.call(-1))[[1]]
    caller <- deparse( sys.call(-1) )
    cat('INFO ', caller, ":", ...)
}


# to be used instead of library(): this function ensures
# that the package is installed if not present in the system
#' use.package
#'
#' checks if a package is installed and loads it, if it is not then it 
#' will install it and then load it
#' 
#' @param	p	a single package name to load
#'
#' @param	silent	whether we want messages produced during the load displayed
#' 
#' @return	the package is guaranteed to be installed and loaded
#'
#' @usage	use.package(p, silent=T)
#' 
#' @examples	use.package('stringr')
#'
#' @author	(C) CNB-CSIC
#'
#' @license	EU-GPL
#'
#' @export
#
use.package <- function(p, silent = F, VERBOSE = F) {
    ### NOTE: we should likely try CRAN first, Bioconductor afterwards,
    ### install.packages offline, devtools::install and install_github
    ### for now we will kepp it simple
    if (!is.element(p, installed.packages()[,1])) {
        # we prefer BiocManager because it can install both Bioconductor
        # and CRAN packages
        #
        #install.packages(p, dep = TRUE)
        if (!is.element('BiocManager', installed.packages()[,1])) {
            install.packages('BiocManager', dependencies=TRUE)
        }
        BiocManager::install(p, dep = TRUE)

    }
    # this will fail for 'banneR' which is neither on CRAN nor on
    # Bioconductor, so we'll check for it as a special case for now
    if (p == 'banneR')
       library(banneR)		# if not available we will do without it
    if (! VERBOSE)
        suppressPackageStartupMessages(require(p, character.only = TRUE))
}



#' use.packages
#'
#' given a vector with one or more package names, it first verifies if all
#' are installed, if not, then missing packages are installed, and finally
#' all the packages are loaded
#' 
#' @param	p	vector of package names to load
#' 
#' @return	the packages are guaranteed to be installed and loaded
#'
#' @usage	use.packages(pkgs)
#' 
#' @examples	use.packages(c('stringr', 'tidyr'))
#'
#' @author	(C) CNB-CSIC
#'
#' @license	EU-GPL
#'
#' @export
#
use.packages <- function(pkgs){
    new.pkgs <- pkgs[!(pkgs %in% installed.packages()[, "Package"])]
    if (length(new.pkgs))
        # if there are uninstalled packages
        install.packages(new.pkgs, dependencies = TRUE)

    sapply(pkgs, require, character.only = TRUE)
}


#'
#'
#'
#' 
#' @param
#' 
#' @return
#'
#' @usage
#' 
#' @examples
#'
#' @author	(C) JosÃ© R. Valverde, CNB-CSIC, 2019
#'
#' @license	EU-GPL
#'
#' @export
#
as.png <- function(PLOT=NULL, 
               file='out.png', width=1024, height=1024, 
               overwrite=TRUE, VERBOSE = T) {

    if (is.null(file)) {
        tryCatch(print(PLOT))
    } else if ( overwrite || ! file.exists(file) ) {
        if (VERBOSE){
            cat("as.png(): creating", file, "\n")
        }
	    tryCatch( {
                png(file, width=width, height=height)
                print(PLOT)
            },
            finally = dev.off()
        )
    }
    return()
}



get_annotation <- function(ensembl.db=NULL, biomart.db='biomaRt.annotation.1st.txt') {
    ensembl.annot <- NULL
    bm.annot.1 <- NULL
    if (! is.null(biomart.db) && file.exists(biomart.db)) {
        # get file extension and convert to lower case to simplify checks
        ext <- tolower(file_ext(biomart.db))
        if (ext == 'tab' || ext == 'tsv' || ext == 'txt') {
            # from .../signif: '../../biomaRt.annotation.1st.txt'
            bm.annot.1 <- read.table(file=biomart.db, header=T)
        } else if (ext == 'rds') {
            bm.annot.1 <- readRDS(biomart.db)
        } else {
            cat.warn('extension of biomart database must be txt, tsv, tab or rds\n')
        }
    }
    if (! is.null(ensembl.db) && file.exists(ensembl.db)) {
        # get file extension and convert to lower case to simplify checks
        ext <- tolower(file_ext(ensembl.db))
        if (ext == 'tab' || ext == 'tsv' || ext == 'txt') {
            # from .../signif: '../../../../net.EnsDb/net.ens.db.rds'
            ensembl.annot <- readRDS(file=ensembl.db)
        } else if (ext == 'rds') {
            ensembl.annot <- readRDS(ensembl.db)
        } else {
            cat.warn('extension of ensembl database must be txt, tsv, tab or rds\n')
        }
    }
    # we could also load an endsb.org.db package
    # and then (but this currently doesn't work for some reason)
    #ens.annot <- ensembldb::select(ens.db, column='GENEID', keytype='GENEID', keys=rownames(dat), columns='SEQNAME')
    # ensembldb::supportedFilters(ens.db)
    # columns(edb)
    # listColumns(edb)
    # keytypes(edb)
    # gids <- keys(edb, keytype = "GENEID")
    # length(gids)
    #ens.ann <- ensembldb::select(ens.db, 
    #              column='GENID', keytype= 'GENEID', keys=rownames(dat), 
    #              columns= c('SEQNAME', 'SYMBOL', 'DESCRIPTION', # no longer available
    #                         'GENENAME', 'GENEID', 'ENTREZID', # empty
    #                         'TXID', 'TXBIOTYPE', # these make the call fail
    #                         'PROTEINID', 'UNIPROTID' # no longer available
    #                          )
    #              )

    return( list(ensembl=ensembl.annot, biomart=bm.annot.1) )
}


enrich_genes <- function(data, ann, data.genes='ensembl_gene_id', ann.genes=data.genes) {
    # add the annotation as additional columns to data, using as the
    # column data.genes from data as index into ann.genes to find the
    # corresponding annotation.
    #
    # use as
    #	annotated.data <- enrich_genes(data, "ensembl.gene.id", ensembl.ann, "GENEID")
    #	annotated.data <- enrich_genes(data, "ensembl.gene.id", biomart.ann, "ensembl_gene_id")
    #
    enriched_genes <- cbind(data, ann[match(data[ , data.genes], ann[ ,ann.genes]), ]) 

    return(enriched_genes)
}


load_l2fc_data <- function(file="all_log2FC_transpose.txt") {
	### XXX JR XXX ###
    # return a list with the datasets that we will use in the subsequent analysis


    # Load log2FC of significantly altered genes:
    #df <- read.table("data/coturnix/rnaseq-test/both_ends/DESeq2/signif/all_log2FC_transpose.txt",header=T)
    # unused    df <- read.table("all_log2FC.txt",header=T)
    fd <- read.table(file, header=T)

    # this ensures that rows get the proper PFU irrespective
    # of order
    #	1. remove prefix
    pfu <- sub("wt.*pfu", "", fd$gene)
    #	2. remove suffix
    pfu <- sub("_l2fc", "", pfu)


    # set name of first column
    #names(fd)[1] <- 'wt.vs.PFU'
    #fd[,1] <- c(0.1, 1.0, 10.0, 100.0)

    # substitute columna1 (file names) by column "$pfu"
    fd <- cbind(pfu=as.numeric(pfu), fd[ , -1])

    # define working data sets
    # 1. add a row of all zeros for the wild.type
    #    (inf.pfu/wt.vs.pfu = 0, l2fc=0 for all genes)
    dat  <- as.data.frame(rbind(rep(0,dim(fd)[2]), fd))
    # 2. remove columns with NAs
    dat.noNA <- dat[ , colSums(is.na(dat))==0]			# remove NAs
    clfc <- dat.noNA
    # we now have
    #	fd 	-> the log2FC transposed data for infected cells (4x8594)
    #	dat -> the log2FC transposed data for wt and infected cells (5x8594)
    #   clfc -> the log2FC transposed data for wt and infected cells without NA-containing columns (5x1182)
    return( list( signif.l2fc.all.data=dat, signif.l2fc.common.data=clfc ) )
}


load_norm_count_data <- function(file="normalized_counts.tab", select=NULL) {
    # load normalized counts of all genes
    nc <- read.table(file=file, row.names=1)
    tnc <- t(nc)
    # prepend a column with infection levels
    # upon read columns are not preserved
    #tnc <- cbind(c(rep(0, 3), rep(0.1, 3), rep(1.0,3), rep(10.0,3), rep(100.0,3)), tnc)
    # so we will fix the labels
    pfu <- rownames(tnc)
    pfu <- sub('^X', '', pfu)
    pfu <- sub('pfu.*', '', pfu)
    pfu <- sub('wt.*', '0.0', pfu)
    pfu <- as.numeric(pfu)
    
    # amend nc and tnc to include a 'pfu' row/column
    nc <- rbind(pfu=pfu, nc)
    tnc <- cbind(pfu=pfu, tnc)
    tnc <- as.data.frame( tnc )		# just in case

    if ( ! is.null(select)) {
        # select only counts of sigfigicantly altered genes:
        sig.nc <- rbind(pfu=nc[1, ], nc[rownames(nc) %in% signif])
        sig.tc <- cbind(pfu=tnc[ ,1], tnc[ , colnames(tnc) %in% select ] )
    #tc <- sig.tc
    } else {
        sig.nc <- nc
        sig.tc <- tnc
    }

    # tc now contains the significant transposed normalized counts	(15x8954)
    # nc contains the significant normalized counts	(8954x15)

    return(list( all_norm_counts=nc, transp_norm_counts=tnc,
                 signif_norm_counts=sig.nc,
                 signif_transp_norm_counts=sig.tc)
}

######################################################################
# load and prepare all required data
######################################################################


data <- load_l2fc_data()
dat <- data$signif.l2fc.all.data
clfc <- data$signif.l2fc.common.data		# common log2FC present in all samples

#ann <- get_annotation('../../../../net.EnsDb/net.ens.db.rds', '../../biomaRt.annotation.1st.txt')
# ens.ann <- ann$ensembl, bio.ann <- ann$biomart
# for now, ensembl does not work during column selection
bio.ann <- get_annotation(ensembl.db=NULL, biomart.db='../../biomaRt.annotation.1st.txt')$biomart
if (is.null(bio.ann)) cat.err("Could not read BIOMART database\n")

all.signif.genes <- colnames(dat)					# genes significant in any pairwise comparison
norm_counts <- load_norm_counts_data(file="../../../normalized_counts.tab", select=all.signif.genes )
# get the dataset that we will use
tc <- norm_counts$signif_transp_norm_counts

# in all, dat, clfc, and tc, the 'pfu' column contains the PFUs used to infect the cells, 0 for wt

# prepare multinomial factor versions of the data (pfu converted to factor) for use when
# regression fails or with categorical methods
fdat <- dat ; fdat$pfu = as.factor(fdat$pfu)
fdatz <- clfc ; fdatz$pfu <- as.factor(fdatz$pfu)
ftc <- tc ; ftc$pfu <- as.factor(ftc$pfu)
# binomial version (just in case) for binomial methods (this should identify wt-specific genes)
btc <- ftc
btc[ ,1] = as.factor(ifelse(btc[ , 1] == 0, 0, 1))
    


##########################################################################################
#
# Now, we can proceed with the analysis of gene importance:
#	we expect to identify the most important genes to "explain" the PFU level (i.e., the
# genes that are more relevantly associated with the response to different PFU infection
# levels); they will likely represent constallations of related genes *whose association
# with the outcome is similar*.
#
##########################################################################################

#
# -- Correlation Method
#
# Pearson Correlation
imp_cor <- function (formula, data, verbose=T) {
# get the left hand side of the formula (the dependent variable) as a sub-formula
fy <- f_lhs(formula)
# convert to column names
ny <- all.vars(fy)
# get the right hand side (the predictor variables) as a sub-formula
fx <- f_rhs(formula)
# convert to column names
nx <- all.vars(fx)
if ( nx == '.' ) {
   nx <- colnames(data)[ colnames(data) != ny ]
} 
# get x and y
y <- data[ , ny]
x <- data[ , nx]

if(verbose) cat.info("calculating correlation between variables\n")

data_cor <- cor(x, y)	

if (verbose) cat.info("selecting variables with cor > 0.8\n")
highlyCorrelated <- rownames(data_cor[data_cor[, 1] > 0.8, , drop = FALSE])

return(highlyCorrelated)
}

if (test_gene_imp) { 
# genes versus infection level
dat.i.cor <- imp_cor(pfu ~ ., dat)
clfc.i.cor <- imp_cor(pfu ~ ., clfc)
tc.i.cor <- imp_cor(pfu ~ ., tc)


if (exists(quote(dat.i.cor)) && ! is.null(dat.i.cor)) {
    edat.i.cor <- data.frame(ensembl_gene_id=(dat.i.cor))
    edat.i.cor <- enrich_genes(edat.i.cor, bio.ann)
    write.table(edat.i.cor, 'impgenes/imp_cor_dat.txt', sep='\t', row.names=F)
}
if (exists(quote(clfc.i.cor)) && ! is.null(clfc.i.cor)) {
    eclfc.i.cor <-data.frame(ensembl_gene_id=clfc.i.cor)
    eclfc.i.cor <- enrich_genes(eclfc.i.cor, bio.ann)
    write.table(eclfc.i.cor, 'impgenes/imp_cor_datz.txt', sep='\t', row.names=F)
}
if (exists(quote(tc.i.cor)) && ! is.null(tc.i.cor)) {
    etc.i.cor <- data.frame(ensembl_gene_id=tc.i.cor)
    etc.i.cor <- enrich_genes(etc.i.cor, bio.ann)
    write.table(etc.i.cor, 'impgenes/imp_cor_tc.txt', sep='\t', row.names=F)
}

}


# -- relimp
#library(relaimpo)
#
# Apply a linear model and get the relative importance of each variable
#
imp_relimp <- function(formula, data, tune=F, verbose=T) {
if (tune == F) {
    if (verbose) cat.info("building linear model\n")
    # directly build a linear model
    regressor <- lm(formula, data=data) # fit a lm() model

} else { 
    if (verbose) cat.info("building linear model with CARET\n")
     # tune with caret
    ### XXX WARNING!!!
    ### MAGIC NUMBERS!!!
    ### WE need to think if this is general or not
    control <- trainControl(method="repeatedcv", number=10, repeats=3)
    tuneGrid <- expand.grid(k=1:3, size=seq(5,20,by=1))	
    regressor <- train(formula, data=data, 
                       method="lm",  # Use "lm" for linear regression
                       preProcess="scale", 
                       trControl=control#,
                       #tuneGrid=tuneGrid
                       )
    # if verbose, plot the regressor
    # use try() to ignore errors at this step.
    if (verbose) try(plot(regressor))		
    if (verbose) cat.info("calculating importance\n")
    if (FALSE) {
        # this is variable importance using CARET
        #result <- calc.relimp(regressor$finalModel, type = "lmg", rela = TRUE) # check how to retrieve the lm from caret result
        result <- caret::varImp(regressor, conditional=TRUE) 	# conditional=True, adjusts for correlations 
    													 	    # between predictors
        return(result)
   } else {
        #to use relimp, we need to access directly the  model
        regressor <- regressor$finalModel
    }
}
if (verbose) try(summary(regressor))
if (verbose) cat.info("calculating importance\n")
relImportance <- calc.relimp(regressor, type = "lmg", rela = TRUE) # calculate relative importance scaled to 100

return(sort(relImportance$lmg, decreasing=TRUE)) # relative importance
}


if (test_gene_imp) {
dat.i.relimp <- imp_relimp(pfu ~ ., dat, tune=T)
clfc.i.relimp <- imp_relimp(pfu ~ ., clfc, tune=T)
tc.i.relimp <- imp_relimp(pfu ~ ., tc, tune=T)			# only one gene selected "ENSCJPG00005008112"



if (! is.null(dat.i.relimp)) {
    edat.i.relimp <- cbind(ensembl_gene_id=rownames(dat.i.relimp), dat.i.relimp)
    edat.i.relimp <- enrich_genes(edat.i.relimp, bio.ann)
    write.table(edat.i.relimp, 'impgenes/imp_relimp_dat.txt', sep='\t', row.names=F)
}
if (! is.null(clfc.i.relimp)) {
    eclfc.i.relimp <- cbind(ensembl_gene_id=rownames(eclfc.i.relimp), eclfc.i.relimp)
    eclfc.i.relimp <- enrich_genes(eclfc.i.relimp, bio.ann)
    write.table(eclfc.i.relimp, 'impgenes/imp_relimp_datz.txt', sep='\t', row.names=F)
}
if (! is.null(tc.i.relimp)) {
    etc.i.relimp <- cbind(ensembl_gene_id=rownames(tc.i.relimp), tc.i.relimp)
    etc.i.relimp <- enrich_genes(etc.i.relimp, bio.ann)
    write.table(etc.i.relimp, 'impgenes/imp_relimp_tc.txt', sep='\t', row.names=F)
}
}



# -- Step-wise Regression Method
# 
# apply a linear model and reduce automatically the number of variable using
# a stepwise approach
#
# If you have large number of predictors , split the Data in chunks of 10
# predictors with each chunk holding the responseVar.

imp_stepwise <- function(formula, data, direction="both", tune=F, verbose=T) {

if (verbose) cat.info("building linear model\n")
# for the base model we need a formula that looks as "dep.var ~ 1"
# take LHS of the formula (the dependent variable) and convert (deparse) to string
y=deparse(f_lhs(formula))
base.formula <- as.formula(paste(y, "~ 1"))		# create the needed base formula
base.mod <- lm(base.formula , data=data) 
if (tune == F) 
    full.mod <- lm(formula, data=data) # full model with all predictors
else  {
    control <- trainControl(method="repeatedcv", number=10, repeats=3)
    full.mod <- train(pfu ~ ., data=tc, method='lm', trControl=control)$finalModel
}

if (verbose) cat.info("calculating importance\n")
stepMod <- step(base.mod, 
		        scope = list(lower = base.mod, upper = full.mod), 
                direction = direction, 
                trace = 1, 
                steps = 1000) 

# according to str() we want to save $Coefficients
return( stepMod$coefficients )
}


if (test_gene_imp) {
dat.i.step <- imp_stepwise(pfu ~ ., dat)		# NA
clfc.i.step <- imp_stepwise(pfu ~ ., clfc)		# NA
tc.i.step <- imp_stepwise(pfu ~ ., tc)			# NA


if (! is.null(dat.i.step)) {
    edat.i.step <- data.frame(ensembl_gene_id=names(dat.i.step), cpeffocient=dat.i.step)
    edat.i.step <- enrich_genes(edat.i.step, bio.ann)
    write.table(edat.i.step, 'impgenes/imp_step_dat.txt', sep='\t', row.names=F)
}
if (! is.null(clfc.i.step)) {
    eclfc.i.step <-data.frame(ensembl_gene_id=names(clfc.i.step), cpeffocient=clfc.i.step)
    eclfc.i.step <- enrich_genes(eclfc.i.step, bio.ann)
    write.table(eclfc.i.step, 'impgenes/imp_step_datz.txt', sep='\t', row.names=F)
}
if (! is.null(tc.i.step)) {
    etc.i.step <- data.frame(ensembl_gene_id=names(tc.i.step), cpeffocient=tc.i.step)
    etc.i.step <- enrich_genes(etc.i.step, bio.ann)
    write.table(etc.i.step, 'impgenes/imp_step_tc.txt', sep='\t', row.names=F)
}
}

#stepwise_result <- perform_stepwise_regression(dat, pfu ~ 1, pfu ~ .)

# The output might include levels within categorical variables, since
# 'stepwise' is a linear regression based technique.
# 
# If you have a large number of predictor variables, the above code may need to
# be placed in a loop that will run stepwise on sequential chunks of
# predictors. The shortlisted variables can be accumulated for further analysis
# towards the end of each iteration. This can be very effective method, if you
# want to
# 
# * Be highly selective about discarding valuable predictor variables. 
# 
# * Build multiple models on the response variable.


#
# -- Recursive Feature Elimination RFE Method

#library(caret)

imp_rfe <- function (formula, data, verbose=T) {
# WE HAVE A FORMULA    y ~ a + b + c ...  or y ~ .
# get the left hand side of the formula (the dependent variable) as a sub-formula
fy <- f_lhs(formula)
# convert to column names
ny <- all.vars(fy)
# get the right hand side (the predictor variables) as a sub-formula
fx <- f_rhs(formula)
# convert to column names
nx <- all.vars(fx)
if ( nx == '.' ) {
   nx <- colnames(data)[ colnames(data) != ny ]
} 
# get x and y
y <- data[ , ny]
x <- data[ , nx]

if (verbose) cat.info("building RFE model\n")
control <- rfeControl(functions=rfFuncs, method="cv", number=10)

results <- rfe(x, y, sizes=2^(2:8), rfeControl=control)

if (verbose) {
    # summarize the results
    # list the chosen features
    predictors(results)
    # plot the results
    plot(results, type=c("g", "o"))
}

if (verbose) cat.info("calculating importance\n")

return(predictors)
}


if (test_gene_imp) {
#    dat.i.rfe <- imp_rfe(pfu ~ ., dat)
#    clfc.i.rfe <- imp_rfe(pfu ~ ., clfc)
#    tc.i.rfe <- imp_rfe(pfu ~ ., tc)


fdat <- dat ; fdat$pfu <- as.factor(fdat$pfu)
fdatz <- clfc ; fdatz$pfu <- as.factor(fdatz$pfu)
ftc <- tc ; ftc$pfu <- as.factor(ftc$pfu)

dat.i.rfe <- imp_rfe(pfu ~ ., fdat)
clfc.i.rfe <- imp_rfe(pfu ~ ., fdatz)
tc.i.rfe <- imp_rfe(pfu ~ ., ftc)


if (! is.null(dat.i.rfe)) {
    edat.i.rfe <- data.frame(ensembl_gene_id=dat.i.rfe)
    edat.i.rfe <- enrich_genes(edat.i.rfe, bio.ann)
    write.table(edat.i.rfe, 'impgenes/imp_rfe_dat.txt', sep='\t', row.names=F)
}
if (! is.null(clfc.i.rfe)) {
    eclfc.i.rfe <- data.frame(ensembl_gene_id=clfc.i.rfe)
    eclfc.i.rfe <- enrich_genes(eclfc.i.rfe, bio.ann)
    write.table(eclfc.i.rfe, 'impgenes/imp_rfe_datz.txt', sep='\t', row.names=F)
}
if (! is.null(tc.i.rfe)) {
    etc.i.rfe <- data.frame(ensembl_gene_id=tc.i.rfe)
    etc.i.rfe <- enrich_genes(etc.i.rfe, bio.ann)
    write.table(etc.i.rfe, 'impgenes/imp_rfe_tc.txt', sep='\t', row.names=F)
}

}


# -- MARS (earth package)
#
# apply a non-linear model using spline curves estimated automatically
#
# The earth package implements variable importance based on Generalized cross
# validation (GCV), number of subset models the variable occurs (nsubsets) and
# residual sum of squares (RSS).
library(earth)

imp_mars <- function (formula, data, verbose=T) {
if (verbose) cat.info("building MARS model\n")
regressor <- earth(formula, data=data) 

if (verbose) cat.info("calculating importance\n")
ev <- evimp (regressor) # estimate variable importance

return(ev)
}

if (test_gene_imp) {
dat.i.mars <- imp_mars(pfu ~ ., data=dat)		# fails because of NAs 	ENSCJPG00005000039
clfc.i.mars <- imp_mars(pfu ~ ., data=clfc)		# same					ENSCJPG00005000039
tc.i.mars <- imp_mars(pfu ~ ., data=tc)			# only one important gene: ENSCJPG00005008112

if (! is.null(dat.i.mars)) {
    edat.i.mars <- cbind(ensembl_gene_id=rownames(dat.i.mars), dat.i.mars)
    edat.i.mars <- enrich_genes(edat.i.mars, bio.ann)
    write.table(edat.i.mars, 'impgenes/imp_mars_dat.txt', sep='\t', row.names=F)
}
if (! is.null(clfc.i.mars)) {
    eclfc.i.mars <- cbind(ensembl_gene_id=rownames(eclfc.i.mars), eclfc.i.mars)
    eclfc.i.mars <- enrich_genes(eclfc.i.mars, bio.ann)
    write.table(eclfc.i.mars, 'impgenes/imp_mars_datz.txt', sep='\t', row.names=F)
}
if (! is.null(tc.i.mars)) {
    etc.i.mars <- cbind(ensembl_gene_id=rownames(tc.i.mars), tc.i.mars)
    etc.i.mars <- enrich_genes(etc.i.mars, bio.ann)
    write.table(etc.i.mars, 'impgenes/imp_mars_tc.txt', sep='\t', row.names=F)
}
}



# 
# -- Learning Vector Quantization (LVQ) Method for CATEGORICAL variables
#

#library(caret)

imp_lvq <- function(formula, data, verbose=T) {
if (vebose) cat.info("building LVQ model\n")
control <- trainControl(method="repeatedcv", number=10, repeats=3)
# to avoid error 'subscript out of bounds'
tuneGrid = expand.grid(k=1:3,size=seq(5,20,by=1))
# train the model
regressor <- train(pfu ~ ., data=data, 
                  method="lvq", 			# error: wrong model for regression
                  preProcess="scale", 
                  trControl=control,
                  tuneGrid=tuneGrid)
if (verbose) cat.info("calculating importance\n")
# estimate variable importance
importance <- caret::varImp(regressor, scale=FALSE)$importance

return(importance)
}

# regressor<- train(pfu ~ ., data=tc, 
#                   method="lvq", 
#                   preProcess="scale", 
#                   trControl=control,
#                   tuneGrid=tuneGrid)
# # estimate variable importance
# importance <- varImp(regressor, scale=FALSE)
#
# for tc only one gene is selected
#	ENSCJPG00005008112


if (test_gene_imp) {

fdat <- dat ; fdat$pfu <- as.factor(fdat$pfu)
fdatz <- clfc ; fdatz$pfu <- as.factor(fdatz$pfu)
ftc <- tc ; ftc$pfu <- as.factor(ftc$pfu)

dat.i.lvq <- imp_lvq(pfu ~ ., fdat)
clfc.i.lvq <- imp_lvq(pfu ~ ., fdatz)
tc.i.lvq <- imp_lvq(pfu ~ ., ftc)


if (! is.null(dat.i.lvq)) {
    edat.i.lvq <- cbind(ensembl_gene_id=rownames(dat.i.lvq), dat.i.lvq)
    edat.i.lvq <- enrich_genes(edat.i.lvq, bio.ann)
    write.table(edat.i.lvq, 'impgenes/imp_lvq_dat.txt', sep='\t', row.names=F)
}
if (! is.null(clfc.i.lvq)) {
    eclfc.i.lvq <- cbind(ensembl_gene_id=rownames(eclfc.i.lvq), eclfc.i.lvq)
    eclfc.i.lvq <- enrich_genes(eclfc.i.lvq, bio.ann)
    write.table(eclfc.i.lvq, 'impgenes/imp_lvq_datz.txt', sep='\t', row.names=F)
}
if (! is.null(tc.i.lvq)) {
    etc.i.lvq <- cbind(ensembl_gene_id=rownames(tc.i.lvq), tc.i.lvq)
    etc.i.lvq <- enrich_genes(etc.i.lvq, bio.ann)
    write.table(etc.i.lvq, 'impgenes/imp_lvq_tc.txt', sep='\t', row.names=F)
}

}




# -- Boruta Method
# 
# The 'Boruta' method can be used to decide if a variable is
# important or not. It is an algorithm based on RF.

# install.packages('Boruta')
#library(Boruta)

imp_boruta <- function (formula, data, getImp='getImpRfZ', verbose=2) {
if (verbose) cat.info("building boruta model\n")

boruta_output <- Boruta(formula, data, doTrace=verbose) # perform Boruta search

# plot results
if (verbose) plot(boruta_output)
#as.png(
#    plot(boruta_output, cex.axis=.7, las=2, xlab="", main="Variable Importance"),
#    file="impgenes/imp_boruta_tc.png") 


if (verbose) cat.info("calculating importance\n")
# get confirmed and tentative factors
# boruta_signif <- names(boruta_output$finalDecision)[boruta_output$finalDecision 
# 									      %in% c("Confirmed", "Tentative")]
# alternate (and more elegant) way
boruta_signif <- getSelectedAttributes(boruta_output, withTentative=T)
if (verbose) attStats(boruta_output)

return(boruta_signif)
}


if (test_gene_imp) {
dat.i.boruta <- imp_boruta(pfu ~ ., dat)
clfc.i.boruta <- imp_boruta(pfu ~ ., clfc)
tc.i.boruta <- imp_boruta(pfu ~ ., tc)

# repeat again to clean up the results for plotting
selected_columns_dat <- cbind(pfu=dat[ ,1], dat[, colnames(dat) %in% boruta_signif])
selected_columns_datz <- cbind(pfu=clfc[ ,1], clfc[, colnames(clfc) %in% boruta_signif])
selected_columns_tc <- cbind(pfu=tc[ ,1], tc[, colnames(tc) %in% tc.i.boruta])


selected.dat.i.boruta <- imp_boruta(pfu ~ ., selected_columns_dat)
selected.clfc.i.boruta <- imp_boruta(pfu ~ ., selected_columns_datz)
selected.tc.i.boruta <- imp_boruta(pfu ~ ., selected_columns_tc)

as.png(
    plot(boruta_signif, cex.axis=.7, las=2, xlab="", main="Variable Importance")
    "impgenes/selected_tc.png")


if (! is.null(dat.i.boruta)) {
    edat.i.boruta <- data.frame(ensembl_gene_id=dat.i.boruta)
    edat.i.boruta <- enrich_genes(edat.i.boruta, bio.ann)
    write.table(edat.i.boruta, 'impgenes/imp_boruta_dat.txt', sep='\t', row.names=F)
}
if (! is.null(clfc.i.boruta)) {
    eclfc.i.boruta <- data.frame(ensembl_gene_id=clfc.i.boruta)
    eclfc.i.boruta <- enrich_genes(eclfc.i.boruta, bio.ann)
    write.table(eclfc.i.boruta, 'impgenes/imp_boruta_datz.txt', sep='\t', row.names=F)
}
if (! is.null(tc.i.boruta)) {
    etc.i.boruta <- data.frame(ensembl_gene_id=tc.i.boruta)
    etc.i.boruta <- enrich_genes(etc.i.boruta, bio.ann)
    write.table(etc.i.boruta, 'impgenes/imp_boruta_tc.txt', sep='\t', row.names=F)
}

}


#
# Repeat Boruta analysis using Ferns variable selection method
#
#library(rFerns)


if (test_gene_imp) {
dat.i.boruta.ferns <- imp_boruta(pfu ~ ., dat, getImp='getImpFerns')
clfc.i.boruta.ferns <- imp_boruta(pfu ~ ., clfc, getImp='getImpFerns')
tc.i.boruta.ferns <- imp_boruta(pfu ~ ., tc, getImp='getImpFerns')


if (! is.null(dat.i.boruta.ferns)) {
    edat.i.boruta.ferns <- data.frame(ensembl_gene_id=dat.i.boruta.ferns)
    edat.i.boruta.ferns <- enrich_genes(edat.i.boruta.ferns, bio.ann)
    write.table(edat.i.boruta.ferns, 'impgenes/imp_boruta.ferns_dat.txt', sep='\t', row.names=F)
}
if (! is.null(clfc.i.boruta.ferns)) {
    eclfc.i.boruta.ferns <- data.frame(ensembl_gene_id=clfc.i.boruta.ferns)
    eclfc.i.boruta.ferns <- enrich_genes(eclfc.i.boruta.ferns, bio.ann)
    write.table(eclfc.i.boruta.ferns, 'impgenes/imp_boruta.ferns_datz.txt', sep='\t', row.names=F)
}
if (! is.null(tc.i.boruta.ferns)) {
    etc.i.boruta.ferns <- data.frame(ensembl_gene_id=tc.i.boruta.ferns)
    etc.i.boruta.ferns <- enrich_genes(etc.i.boruta.ferns, bio.ann)
    write.table(etc.i.boruta.ferns, 'impgenes/imp_boruta.ferns_tc.txt', sep='\t', row.names=F)
}

}


#
# -- rpart
#library(rpart)
#library(caret)

imp_rpart <- function(formula, data, tune=F, verbose=T) {
if (tune == F) {
    if (verbose) cat.info("building rpart model\n")
    # this rcontrol was taken from iv_num in package 'riv'
    #	CAUTION: MAGIC NUMBERS
    minbucket <- nrow(data)/10
    if (minbucket < 1) minbucket <- 1
    rcontrol <- rpart.control(cp=0.001, minbucket=minbucket)
    model <- rpart(data=tc, formula=formula, control=rcontrol)
    # we need now a way to calculate importance. woe/riv might
    # be a good one if it did work, so we will use the ones
    # rpart itself calculates
    # model$variable.importance is a named vector of weights with variables as names
    return(model$variable.importance)
} else {	# (tune == TRUE)
    if (verbose) cat.info("building rpart model with CART\n")
    set.seed(SEED)
    # CAUTION: MAGIC NUMBERS
    trainControl= trainControl(method="repeatedcv", repeats=5)
    rPartMod <- train(formula, 
                      data=data, 
                      method="rpart",
                      importance=T,
                      trControl=trainControl)

    if (verbose) cat.info('calculating importance\n')
    rpartImp <- caret::varImp(rPartMod, scale=F)

    return(rpartImp)
}
}



if (test_gene_imp) { 
# with dat: Something is wrong; all the RMSE metric values are missing
# with clfc: Something is wrong; all the RMSE metric values are missing Model fit failed Argument importance not matched
# with tc: Something is wrong; all the RMSE metric values are missing Model fit failed Argument importance not matched
# with ftc: Something is wrong; all the Accuracy metric values are missing: etc.
dat.i.rpart <- imp_rpart(pfu ~ . , data=dat)		# with tune=TRUE gives ERROR: RMSD values missing
clfc.i.rpart <- imp_rpart(pfu ~ . , data=clfc)		# with tune=TRUE gives ERROR: RMSD values missing
tc.i.rpart <- imp_rpart(pfu ~ . , data=tc)
# tc.i.rpart <- imp_rpart(pfu ~ . , data=ftc)

if (! is.null(dat.i.rpart)) {
    edat.i.rpart <- data.frame(ensembl_gene_id=names(dat.i.rpart), dat.i.rpart)
    edat.i.rpart <- enrich_genes(edat.i.rpart, bio.ann)
    write.table(edat.i.rpart, 'impgenes/imp_rpart_dat.txt', sep='\t', row.names=F)
}
if (! is.null(clfc.i.rpart)) {
    eclfc.i.rpart <- data.frame(ensembl_gene_id=names(clfc.i.rpart), clfc.i.rpart)
    eclfc.i.rpart <- enrich_genes(eclfc.i.rpart, bio.ann)
    write.table(eclfc.i.rpart, 'impgenes/imp_rpart_datz.txt', sep='\t', row.names=F)
}
if (! is.null(tc.i.rpart)) {
    etc.i.rpart <- data.frame(ensembl_gene_id=names(tc.i.rpart), tc.i.rpart)
    etc.i.rpart <- enrich_genes(etc.i.rpart, bio.ann)
    write.table(etc.i.rpart, 'impgenes/imp_rpart_tc.txt', sep='\t', row.names=F)
}
}



if (FALSE) {
# -- Information value and Weight of evidence Method
# 		Use for binary outcomes (try e.g. with 0 vs 100)
#		Uses rpart for building an initial model
# NO LONGER MAINTAINED. DOES NOT WORK
#	
library(devtools)
   install_github("tomasgreif/woe")
   install_github("tomasgreif/riv")
library(woe)
library(riv)

data <- btc
iv_df <- iv.mult(data, y="pfu", summary=TRUE, verbose=TRUE)	
# seems to be able to build an rpart model, with 5 rules, but then gives
# Error in iv.str(df, "tmp_iv_calc_label", y) : Not a binary outcome
iv <- iv.mult(data, y="pfu", summary=FALSE, verbose=TRUE)
iv_df
iv.plot.summary(iv_df) # Plot information value summary
# Calculate weight of evidence variables
data_iv <- iv.replace.woe(dat, iv, verbose=TRUE) # add woe variables to original data frame.

# The newly created woe variables can alternatively be in place of the original
# factor variables.
# NO LONGER MAINTAINED. DOES NOT WORK
# it seems now we should use woe, but it is very limited and DOES NOT WORK
# woe(Data=btc, independent="column.name", Continuous=T, dependent="pfu", C_bin=2, Bad=1, Good=0)
}




# -- random forest
# Random forest can be very effective to find a set of predictors that best
# explains the variance in the response variable.
# library(caret)
# library(randomForest)
# This function builds a Random Forest to find the most relevant variables
#
# A Random Forest is like 'rpart' but with many decision trees instead of only one
#
imp_random_forest <- function(formula, data, verbose=T, method='rangerRF', ...) {
# create a RF model
if (verbose) cat.info("building RF model\n")
if (method == 'rangerRF') {
    # Ranger is a (not so) fast implementation of random forest particularly suited for high
    # dimensional data... 
    # ..and seems to work for <= 5 samples
    if (verbose) cat.info("calculating importance\n")	# we can do both together with ranger
    regressor <- ranger::ranger(formula, data=data, 
                                importance='permutation', 
                                           local.importance=T,
                                           scale.permutation.importance=T)
    return(regressor$variable.importance)			# importance for each independent variable
    #return(regressor$variable.importance.local)	# importance for each variable and for each sample
}
# else (if method == 'RF')
regressor <- randomForest(formula , data=data, importance=TRUE, ...)  # fit the random forest with 
                                                                      # provided parameters (if any)
if (verbose) cat.info("calculating importance\n")
# get variable importance, based on mean decrease in accuracy using
# varImp in the caret package (we indicate it explicitly to avoid name clashes due to masking)
if ( TRUE ) {
    result <- caret::varImp(regressor, conditional=TRUE) 	# conditional=True, adjusts for correlations 
    													 	# between predictors
    return(result)
} else {
    # unused for now, we will activate it eventually and add a function-call argument
    # to allow choosing
    varImp::varimpAUC(regressor)    # more robust towards class imbalance, returns a list
    return(result$importance)
}
}

if (test_gene_imp) { 
# dat can have NAs, the others don't
#dat.i.rf <- imp_random_forest(pfu ~ ., dat, na.action=na.omit)
clfc.i.rf <- imp_random_forest(pfu ~ ., clfc)
tc.i.rf <- imp_random_forest(pfu ~ ., tc)

# all of these fail with method='RF' because we only have five infection levels
#	==> according to Google searches we cannot use RF for regression with <= 5 levels
# this means we cannot use regression, and we need to resort to 
# classification, treating the infection levels as a factor
# (this is, we treat PFU levels as categorical variables, which
# implies we will ignore the magnitude of $pfu):
#	convert $pfu to factor and try again
# now do the (categorical) importance calculations
fdat.i.rf <- imp_random_forest(pfu ~ ., fdat, na.action=na.omit)		# need at least two classes
fdatz.i.rf <- imp_random_forest(pfu ~ ., fdatz)						# 
ftc.i.rf <- imp_random_forest(pfu ~ ., ftc)							# 

# for rangerRF (for RF change names() by rownames()
if (exists(quote(dat.i.rf)) && ! is.null(dat.i.rf)) {
    edat.i.rf <- cbind(ensembl_gene_id=names(dat.i.rf), dat.i.rf)
    edat.i.rf <- enrich_genes(edat.i.rf, bio.ann)
    write.table(edat.i.rf, 'impgenes/imp_rf_dat.txt', sep='\t', row.names=F)
}
if (exists(quote(clfc.i.rf)) && ! is.null(clfc.i.rf)) {
    eclfc.i.rf <- cbind(ensembl_gene_id=names(clfc.i.rf), clfc.i.rf)
    eclfc.i.rf <- enrich_genes(eclfc.i.rf, bio.ann)
    write.table(eclfc.i.rf, 'impgenes/imp_rf_datz.txt', sep='\t', row.names=F)
}
if (exists(quote(tc.i.rf)) && ! is.null(tc.i.rf)) {
    etc.i.rf <- cbind(ensembl_gene_id=names(tc.i.rf), tc.i.rf)
    etc.i.rf <- enrich_genes(etc.i.rf, bio.ann)
    write.table(etc.i.rf, 'impgenes/imp_rf_tc.txt', sep='\t', row.names=F)
}

}



#
# 15. Regularized Random Forest (RRF)
imp_rrf <- function ( formula, data, verbose=T ) {
if (verbose) cat.info("building RRF model\n")

set.seed(SEED)

if (verbose) cat.info("building rrf model\n")
rrfMod <- train(formula, 
            data = data, 
            method = "RRF",
            importance = T) #this argument is required for varImp

if (verbose) cat.info('calculating importance\n')
rrfImp <- caret::varImp(rrfMod, scale=F)

if (verboise) as.png(
				plot(rrfImp, top = 20, main='Variable Importance'),
                file="impgenes/rrf_tc.png", verbose)

if(verbose) plot(rrfImp$importance)

return(rrfImp$importance)
}

if (test_gene_imp) { 
#dat.i.rrf <- imp_rrf(pfu ~ . , data=dat)		# ERROR: RMSD values missing
#clfc.i.rrf <- imp_rrf(pfu ~ . , data=clfc)		# same
tc.i.rrf <- imp_rrf(pfu ~ . , data=tc)

if (exists(quote(dat.i.rrf)) && ! is.null(dat.i.rrf)) {
    edat.i.rrf <- cbind(ensembl_gene_id=rownames(dat.i.rrf), dat.i.rrf)
    edat.i.rrf <- enrich_genes(edat.i.rrf, bio.ann)
    write.table(edat.i.rrf, 'impgenes/imp_rrf_dat.txt', sep='\t', row.names=F)
}
if (exists(quote(clfc.i.rrf)) && ! is.null(clfc.i.rrf)) {
    eclfc.i.rrf <- cbind(ensembl_gene_id=rownames(clfc.i.rrf), clfc.i.rrf)
    eclfc.i.rrf <- enrich_genes(eclfc.i.rrf, bio.ann)
    write.table(eclfc.i.rrf, 'impgenes/imp_rrf_datz.txt', sep='\t', row.names=F)
}
if (exists(quote(tc.i.rrf)) && ! is.null(tc.i.rrf)) {
    etc.i.rrf <- cbind(ensembl_gene_id=rownames(tc.i.rrf), tc.i.rrf)
    etc.i.rrf <- enrich_genes(etc.i.rrf, bio.ann)
    write.table(etc.i.rrf, 'impgenes/imp_rrf_tc.txt', sep='\t', row.names=F)
}

}




#
#
# -- DALEX Method

#library(randomForest)
#library(DALEX)
#library(h2o)


imp_dalex <- function(formula, data, method='rangerRF', verbose=T) {
if (verbose) cat.info("building DALEX model with", method, "\n")
if (method == "rf") {
    regressor <- randomForest(formula , data=data, importance=TRUE) 
    # fit the random forest with default parameters
} else if (method == "rangerRF") {
    # Ranger is a (not so) fast implementation of random forest particularly suited for high
    # dimensional data... 
    regressor <- ranger::ranger(formula, data=data, 
                                importance='permutation', 
                                           local.importance=T,
                                           scale.permutation.importance=T)
} else if (method == "bGLM") {
    regressor <- glm(formula , data=data, family='binomial')
} else if (method == "mGLM") {
    cat.warn('multinomial models are unsupported\n')
    regressor <- glm(formula , data=data, family='multinomial')
} else if (method == "gGLM") {
    regressor <- glm(formula , data=data, family='gaussian')
}  else {
    cat.err("unknown method", method, '\n')
}

if (verbose) cat.info("calculating importance\n")
# Variable importance with DALEX
# we need 'y', and to get it we need to parse the formula:
#    all.vars returns all the variables that have been used in the formula
#    so, the first element is the 'y' component (y ~ a · b · ...)
y <- all.vars(formula)[1]
# and now we use as y the column named y
explained <- DALEX::explain(regressor, data=data, y=data[ , y], label=method)
#
# residuals <- model_performance(explained)
# plot(residuals)
# vip <- DALEX::variable_importance(explained) 
# pdp <- DALEX::variable_response(explained, variable=*select one var*, type='pdp')

DALEX=T
if (DALEX=T) {
    if (verbose) cat.info('extracting variable importance (slow)\n')
    vip <- DALEX::variable_importance(explained)
} else {
    if (verbose) cat.info('extracting feature importance (slow)\n')
    # Get the variable importances
    #varimps <- variable_dropout(explained, type='raw')
    #print(varimps)
    #plot(varimps)
    vip <- DALEX::feature_importance(explained, type='raw') # very slow
    # plot 20 most important
    if (verbose) {
        nv<-dim(vip)[1] / length(levels(as.factor(vip$permutation)))
        as.png(plot(vip[c(1,(nv-20):nv),]), 'impgenes/top20_dalex.png')
    }
    # get mean loss and sort to get variable importance
    vip.mean.loss <- aggregate(vip$dropout_loss, list(vip$variable), mean)
    imp <- (vip.mean.loss[ order(vip.mean.loss$x, decreasing=F),])
    colnames(imp) <- c('variable', 'mean_dropout_loss')
    #print(imp)
    #head(imp)
    #head(sort(imp))
    return ( imp )
} 
}


if (test_gene_imp) {
# RF does not work for our dataset, so this selection method
# will neither.

# If we use an RF model, since we have less than six values, we need
# to use a categorical RF
fdat <- dat ; fdat$pfu <- as.factor(fdat$pfu)
fdatz <- clfc ; fdatz$pfu <- as.factor(fdatz$pfu)
ftc <- tc ; ftc$pfu <- as.factor(ftc$pfu)

# but if we use rangerRF, it seems to work
# and so it does seem to work with gGLM
fdat.i.dalex <- imp_dalex(pfu ~ ., fdat)
fdatz.i.dalex <- imp_dalex(pfu ~ ., fdatz)
ftc.i.dalex <- imp_dalex(pfu ~ ., ftc)

dat.i.dalex <- imp_dalex(pfu ~ ., dat, method='rangerRF')
clfc.i.dalex <- imp_dalex(pfu ~ ., clfc, method='rangerRF')
tc.i.dalex <- imp_dalex(pfu ~ ., tc, method='rangerRF')


if (exists(quote(dat.i.dalex)) && ! is.null(dat.i.dalex)) {
    edat.i.dalex <- dat.i.dalex ; colnames(edat.i.dalex) <- c('ensembl_gene_id', 'mean_dropout_loss')
    edat.i.dalex <- enrich_genes(edat.i.dalex, bio.ann)
    write.table(edat.i.dalex, 'impgenes/imp_dalex_dat.txt', sep='\t', row.names=F)
}
if (exists(quote(clfc.i.dalex)) && ! is.null(clfc.i.dalex)) {
    eclfc.i.dalex <- clfc.i.dalex ; colnames(eclfc.i.dalex) <- c('ensembl_gene_id', 'mean_dropout_loss')
    eclfc.i.dalex <- enrich_genes(eclfc.i.dalex, bio.ann)
    write.table(eclfc.i.dalex, 'impgenes/imp_dalex_datz.txt', sep='\t', row.names=F)
}
if (exists(quote(tc.i.dalex)) && ! is.null(tc.i.dalex)) {
    etc.i.dalex <- tc.i.dalex ; colnames(etc.i.dalex) <- c('ensembl_gene_id', 'mean_dropout_loss')
    etc.i.dalex <- enrich_genes(etc.i.dalex, bio.ann)
    write.table(etc.i.dalex, 'impgenes/imp_dalex_tc.txt', sep='\t', row.names=F)
}
}

#
# -- VITA

library(vita)

imp_vita <- function (formula, data, method='RF', verbose=T) {
if (verbose) cat.info("building RF model\n")

if (method == 'rangerRF') {
    # Ranger is a (not so) fast implementation of random forest particularly suited for high
    # dimensional data... 
    # ..and seems to work for <= 5 samples
    # BUT it is not accepted by 'vita'
    #	XXX NOTE XXX We need to find a way to transform it to RF
    #	meanwhile, DO NOT USE THIS
    regressor <- ranger::ranger(formula, data=data, 
                                importance='permutation', 
                                           local.importance=T,
                                           scale.permutation.importance=T)
}  else if (method == 'RF') {
    regressor <- randomForest(formula , data=data, importance=TRUE)  # fit the random forest with 
}

if (verbose) cat.info("calculating importance\n")
y <- all.vars(formula)[1]
pimp.varImp.reg <- PIMP(data, data[ , y], regressor,S =10, parallel=TRUE)
return(pimp.varImp.reg$VarImp[order(pimp.varImp.reg$VarImp, decreasing=T),])
}

if (test_gene_imp) {
dat.i.vita <- imp_vita(pfu ~ . , data=fdat)
clfc.i.vita <- imp_vita(pfu ~ . , data=fdatz)
tc.i.vita <- imp_vita(pfu ~ . , data=ftc)

if (exists(quote(dat.i.vita)) && ! is.null(dat.i.vita)) {
    edat.i.vita <- cbind(ensembl_gene_id=rownames(t(dat.i.vita)), t(dat.i.vita))
    edat.i.vita <- enrich_genes(edat.i.vita, bio.ann)
    write.table(edat.i.vita, 'impgenes/imp_vita_dat.txt', sep='\t', row.names=F)
}
if (exists(quote(clfc.i.vita)) && ! is.null(clfc.i.vita)) {
    eclfc.i.vita <- cbind(ensembl_gene_id=names(t(clfc.i.vita)), clfc.i.vita)
    eclfc.i.vita <- enrich_genes(eclfc.i.vita, bio.ann)
    write.table(eclfc.i.vita, 'impgenes/imp_vita_datz.txt', sep='\t', row.names=F)
}
if (exists(quote(tc.i.vita)) && ! is.null(tc.i.vita)) {
    etc.i.vita <- cbind(ensembl_gene_id=names(tc.i.vita), tc.i.vita)
    etc.i.vita <- enrich_genes(etc.i.vita, bio.ann)
    write.table(etc.i.vita, 'impgenes/imp_vita_tc.txt', sep='\t', row.names=F)
}

}


# -- LASSO regression
#library(glmnet)

# this works for both continuous and categorical variables
imp_glmnet <- function (formula, data, verbose=T) {
# get the left hand side of the formula (the dependent variable) as a sub-formula
fy <- f_lhs(formula)
# convert to column names
ny <- all.vars(fy)
# get the right hand side (the predictor variables) as a sub-formula
fx <- f_rhs(formula)
# convert to column names
nx <- all.vars(fx)
if ( nx == '.' ) {
   nx <- colnames(data)[ colnames(data) != ny ]
} 
# get x and y
y <- data[ , ny]
x <- data[ , nx]


# make y binomial
#y <- as.double(as.matrix(ifelse(y == 0.0, 0, 1))) 
#y <- as.double(as.matrix(y))

if(verbose) cat.info("building glmnet model\n")
set.seed(SEED)
if (is.factor(y)) {
    if (length(levels(y)) == 2) {
        family <-'binomial'
    } else {
        family='multinomial'
    }
    if (verbose) cat.info("y is a factor, using a", family, "glmnet model\n")
} else {
    if (verbose) cat.info("assuming gaussian y\n")
    family='gaussian'
}        
cv.lasso <- cv.glmnet(as.matrix(x), y, family=family, 
    		 		  alpha=1, 			# 0 -> ridge, 1-> LASSO
                      parallel=TRUE, 
                      standardize=TRUE #, 
                      #type.measure='auc'
                     )
# Least Absolute Shrinkage and Selection Operator (LASSO) penalizes with L1-norm.
#     It imposes a cost to having large weights (value of coefficients). 
#	  It is called L1 regularization, because the cost added, is
# proportional to the absolute value of weight coefficients.
# As a result, it reduces the coefficients of unwanted variables to zero leaving
# only the important ones.

if (verbose) plot(cv.lasso)
# plot with two vertical lines: first is the lambda with lowers mean squared error
# and second the number of variables with highest deviance within 1 SD

if (verbose) cat.info("calculating importance\n")
# the best lambda value is stored in $lambda,min
if (family != 'multinomial') {
    coef<- round(as.matrix(coef(cv.lasso, s=cv.lasso$lambda.min)), 2)
    coef <- coef[coef[ ,1] !=0, ]
} else {
    coef <- list()
    for (i in levels(y)) {   # we get a set of coefficients for each level
        level.coef <- round(as.matrix(coef(cv.lasso, s=cv.lasso$lambda.min)[[ i ]]), 2)
        coef[[i]] <- level.coef[ level.coef[ ,1] != 0, ]
    }
}

# another way
#coefList <- coef(cv.lasso, s='lambda.1se')
#coefList <- data.frame(coefList@Dimnames[[1]][coefList@i+1],coefList@x)
#names(coefList) <- c('var','val')


# return coefficients with lambda value !=0
return( coef )

}

if (test_gene_imp) { 
dat.i.glmnet <- imp_glmnet(pfu ~ . , data=dat)
clfc.i.glmnet <- imp_glmnet(pfu ~ . , data=clfc)
tc.i.glmnet <- imp_glmnet(pfu ~ . , data=tc)
ftc <- tc ; ftc$pfu <- as.factor(ftc$pfu)
ftc.i.glmnet <- imp_glmnet(pfu ~ . , data=ftc)
btc <- ftc
btc[ ,1] = as.factor(ifelse(btc[ , 1] == 0, 0, 1))
btc.i.glmnet <- imp_glmnet(pfu ~ . , data=btc)

if (exists(quote(dat.i.glmnet)) && ! is.null(dat.i.glmnet)) {
    edat.i.glmnet <- cbind(ensembl_gene_id=names(dat.i.glmnet), dat.i.glmnet)
    edat.i.glmnet <- enrich_genes(edat.i.glmnet, bio.ann)
    write.table(edat.i.glmnet, 'impgenes/imp_glmnet_dat.txt', sep='\t', row.names=F)
}
if (exists(quote(clfc.i.glmnet)) && ! is.null(clfc.i.glmnet)) {
    eclfc.i.glmnet <- cbind(ensembl_gene_id=names(clfc.i.glmnet), clfc.i.glmnet)
    eclfc.i.glmnet <- enrich_genes(eclfc.i.glmnet, bio.ann)
    write.table(eclfc.i.glmnet, 'impgenes/imp_glmnet_datz.txt', sep='\t', row.names=F)
}
if (exists(quote(tc.i.glmnet)) && ! is.null(tc.i.glmnet)) {
    etc.i.glmnet <- cbind(ensembl_gene_id=names(tc.i.glmnet), tc.i.glmnet)
    etc.i.glmnet <- enrich_genes(etc.i.glmnet, bio.ann)
    write.table(etc.i.glmnet, 'impgenes/imp_glmnet_tc.txt', sep='\t', row.names=F)
}

}



# -- xgboost
#library(caret)
#library(xgboost)

imp_xgboost <- function(formula, data, verbose=T) {
if (verbose) cat.info("building xgboost model\n")

regressor <- train(formula, data, 
                   method = "xgbTree", 
                   trControl = trainControl("cv", number = 10))
                   # scale=TRUE)
if (verbose) cat.info("calculating importance\n")
result <- caret::varImp(regressor, conditional=T)

# according to str() we want to save $importance from caret::varImp() results
return(result$importance)
}

if (test_gene_imp) {
dat.i.xgboost <- imp_xgboost(pfu ~ ., dat)
clfc.i.xgboost <- imp_xgboost(pfu ~ ., clfc)
tc.i.xgboost <- imp_xgboost(pfu ~ ., tc)

if (! is.null(dat.i.xgboost)) {
    edat.i.xgboost <- cbind(ensembl_gene_id=rownames(dat.i.xgboost), dat.i.xgboost)
    edat.i.xgboost <- enrich_genes(edat.i.xgboost, bio.ann)
    write.table(edat.i.xgboost, 'impgenes/imp_xgboost_dat.txt', sep='\t', row.names=F)
}
if (! is.null(clfc.i.xgboost)) {
    eclfc.i.xgboost <- cbind(ensembl_gene_id=rownames(eclfc.i.xgboost), eclfc.i.xgboost)
    eclfc.i.xgboost <- enrich_genes(eclfc.i.xgboost, bio.ann)
    write.table(eclfc.i.xgboost, 'impgenes/imp_xgboost_datz.txt', sep='\t', row.names=F)
}
if (! is.null(tc.i.xgboost)) {
    etc.i.xgboost <- cbind(ensembl_gene_id=rownames(tc.i.xgboost), tc.i.xgboost)
    etc.i.xgboost <- enrich_genes(etc.i.xgboost, bio.ann)
    write.table(etc.i.xgboost, 'impgenes/imp_xgboost_tc.txt', sep='\t', row.names=F)
}
}


#
# -- Genetic Algorithm

library(caret)

imp_ga <- function (formula, data, verbose=T) {
# get the left hand side of the formula (the dependent variable) as a sub-formula
fy <- f_lhs(formula)
# convert to column names
ny <- all.vars(fy)
# get the right hand side (the predictor variables) as a sub-formula
fx <- f_rhs(formula)
# convert to column names
nx <- all.vars(fx)
if ( nx == '.' ) {
   nx <- colnames(data)[ colnames(data) != ny ]
} 
# get x and y
y <- data[ , ny]
x <- data[ , nx]

if (verbose) cat.info("building GA model\n")
# Define control function
ga_ctrl <- gafsControl(functions = rfGA,  method = "cv", repeats = 3)
# another option is `caretGA`
# Genetic Algorithm feature selection
ga_obj <- gafs(x,
 	          y,
 	          iters = 100,  # normally much higher (100+)        
  	          gafsControl = ga_ctrl)

return(ga_obj$optVariables)
}

if (test_gene_imp) {
dat.i.ga <- imp_ga(pfu ~ ., dat)
clfc.i.ga <- imp_ga(pfu ~ ., clfc)
tc.i.ga <- imp_ga(pfu ~ ., tc)

if (exists(quote(dat.i.ga)) && ! is.null(dat.i.ga)) {
    edat.i.ga <- data.frame(ensembl_gene_id=(dat.i.ga))
    edat.i.ga <- enrich_genes(edat.i.ga, bio.ann)
    write.table(edat.i.ga, 'impgenes/imp_ga_dat.txt', sep='\t', row.names=F)
}
if (exists(quote(clfc.i.ga)) && ! is.null(clfc.i.ga)) {
    eclfc.i.ga <-data.frame(ensembl_gene_id=clfc.i.ga)
    eclfc.i.ga <- enrich_genes(eclfc.i.ga, bio.ann)
    write.table(eclfc.i.ga, 'impgenes/imp_ga_datz.txt', sep='\t', row.names=F)
}
if (exists(quote(tc.i.ga)) && ! is.null(tc.i.ga)) {
    etc.i.ga <- data.frame(ensembl_gene_id=tc.i.ga)
    etc.i.ga <- enrich_genes(etc.i.ga, bio.ann)
    write.table(etc.i.ga, 'impgenes/imp_ga_tc.txt', sep='\t', row.names=F)
}

}


#
# -- Simulated Annealing

library(caret)

imp_sa <- function (formula, data, verbose=T) {
# get the left hand side of the formula (the dependent variable) as a sub-formula
fy <- f_lhs(formula)
# convert to column names
ny <- all.vars(fy)
# get the right hand side (the predictor variables) as a sub-formula
fx <- f_rhs(formula)
# convert to column names
nx <- all.vars(fx)
if ( nx == '.' ) {
   nx <- colnames(data)[ colnames(data) != ny ]
} 
# get x and y
y <- data[ , ny]
x <- data[ , nx]

if (verbose) cat.info("building SA model\n")
# Define control function  
sa_ctrl <- safsControl(functions = rfSA,
                       method = "repeatedcv",            
                       repeats = 3,            
                       improve = 5)

set.seed(SEED)
# Simulated Annealing feature selection
sa_obj <- safs(x, 
    		   y,
               safsControl = sa_ctrl)

return(sa_obj$optVariables)
}

if (test_gene_imp) {
dat.i.sa <- imp_sa(pfu ~ ., dat)
clfc.i.sa <- imp_sa(pfu ~ ., clfc)
tc.i.sa <- imp_sa(pfu ~ ., tc)


if (exists(quote(dat.i.sa)) && ! is.null(dat.i.sa)) {
    edat.i.sa <- data.frame(ensembl_gene_id=(dat.i.sa))
    edat.i.sa <- enrich_genes(edat.i.sa, bio.ann)
    write.table(edat.i.sa, 'impgenes/imp_sa_dat.txt', sep='\t', row.names=F)
}
if (exists(quote(clfc.i.sa)) && ! is.null(clfc.i.sa)) {
    eclfc.i.sa <-data.frame(ensembl_gene_id=clfc.i.sa)
    eclfc.i.sa <- enrich_genes(eclfc.i.sa, bio.ann)
    write.table(eclfc.i.sa, 'impgenes/imp_sa_datz.txt', sep='\t', row.names=F)
}
if (exists(quote(tc.i.sa)) && ! is.null(tc.i.sa)) {
    etc.i.sa <- data.frame(ensembl_gene_id=tc.i.sa)
    etc.i.sa <- enrich_genes(etc.i.sa, bio.ann)
    write.table(etc.i.sa, 'impgenes/imp_sa_tc.txt', sep='\t', row.names=F)
}
}




#
##################################################################################################
##################################################################################################
##################################################################################################
##################################################################################################


#
# EFA
#

dat=fd
dat.zero <- dat  # copia
dat.zero[is.na(dat.zero)] <- 0 # reemplazo con 0 los valores nulos
dat.std <- data.frame(scale(dat.zero , center=TRUE, scale=TRUE)) #estandarizar datos
# describe(dat.std)

# correlation plot from 'corrplot'
if (F) {
library('corrplot')
corrplot(cor(dat, use="complete.obs"), 
         order = "original", 		# also try 'hclust'
         tl.col='black', tl.cex=.75) 
}


# FACTANAL() FAILS (SINGULAR MATRIX)
{
# EFA with no rotation 
# (also try rotation = varimax, promax, oblimin)
# (also try scores="regression", "Barlett")
efa.result <- factanal( ~ . , data=dat, factors=10, rotation="none", na.action=na.exclude) #note the formula specification allows NA
efa.result <- factanal( ~ . , data=dat, factors=10, rotation="varimax", na.action=na.exclude) #note the formula specification allows NA

# look at sums of squared loadings (eigenvalues, variance explained by factor)
# factor 1
loadings_fac1 = efa.result$loadings[,1] 
eigenv_fac1 <- sum(loadings_fac1 ^ 2)

# uniqueness (1 - communality)
#    where communality = sum(ss of all factor loadings of a variable)
efa.result$uniquenesses
# variable 1
# Calculate communality
loadings_V1 <- efa.result$loadings[1,]  #loadings for first variable (1st row of Lambda)
communality_V1 <- sum(loadings_V1 ^ 2)  #SS of factor loadings
uniqueness_V1 <- 1-communality_V1

# plot factor loadings for first two factors
load <- efa.result$loadings[,1:2]
plot(load, type="n") # set up plot 
text(load,labels=names(dat),cex=.7) # add variable names

}

# THIS ONE HANGS FOREVER
if (F) {
library(psych)
library(nFactors)
efa.res <- fa(r=cor.dat, nfactors=10, rotate="oblimin", fm="pa")
efa.res <- fa(r=cor.dat.std, nfactors=10, rotate="oblimin", fm="pa")

cor.dat <- cor(clfc[ , colnames(clfc) != "pfu"], datz$pfu)
efa.res <- fa(r=cor.dat, nfactors=4, rotate="oblimin", fm="pa")

}
# OTHER EFA IMPLEMENTATIONS ALSO FAIL


#
# EGA
#
# THIS FAILS TOO AFTER A LONG TIME (FORTRAN error)
if (F) {
library("devtools")
devtools::install_github('hfgolino/EGA')

library(EGAnet)
ega.res <- EGA(data=dat.std, model='glasso')	# fails (FORTRAN error)
ega.res <- EGA(data=dat.std)
# fails to compute due to FORTRAN error about long vectors
}


#
# EFA taken more carefully
#
#	I tried to repeat EFA using the three corrected counts. 
#
# With all data it takes too long. So, I tried using smaller subsets.
# with 100 genes it worked for psych::fa (other implementations failed
# at singular matrix steps, psych::fa detects the situation and takes
# a detour (uses the pseudo-inverse) to complete the calculations.
#
# Trying with increasing numbers of genes (200, 400, 800) also completed
# but took much longer
#
# This led to two observations:
#	1) we do not need all genes, only ones with significant l2FC
#	2) in the cases where fa.parallel was allowed to run to completion
#	   the optimal number of hidden variables seems to be either 4 (by
#      the intersection with simulated data) or 6 (by the elbow method)
#
# Applying EFA with psych::fa() to the significant l2FC dataset using
# 6 as the number of factors works more or less... depending on the
# method: some methods will result in unreliable factoring, some in
# calculation problems, and some simply work. Increasing the number of
# factors reaches a point where the calculation fails.
#
# This led to additional observations:
#   1) choosing an appropriate number of factors will determine completion
#	2) choosing an appropriate combination of methods will also determine
#      completion.
#
# After this, I decided to retake the calculations with the log2FC data
# directly again applying what I had learnt from the count data and now
# we can make it work.
#
# The plots of hidden factors suggest that there is a major one that
# includes the (0, 0.1, 1, 10, 100) column. These would be the genes
# that correlate linearly with infection level. The other groups are
# genes with coherent responses that do not follow the infection level
# pattern. They may still be highly relevant and biologically significant
# but we need to identify what they do.
#
#	Corollary: we need now to separate the factor components and annotate
# them.
#
# Another element to investigate is what happens if we isolate the group
# of genes that correlate with infection level and run EFA again on them.
# With a bit of luck, after removing extra "noise" we might be able to
# further isolate additional subgroups.
#
# This is the analysis that worked (removing the partial analyses):
#
{
library(corrplot)
library(factoextra)
library(ctv)
library(psych)
library(psychTools)
library(nFactors)


    # load normalized counts of all genes
    nc <- read.table(file="normalized_counts.tab", header=T)
    tnc <- t(nc)
    # prepend a column with infection levels
    # upon read columns are not preserved
    #tnc <- cbind(c(rep(0, 3), rep(0.1, 3), rep(1.0,3), rep(10.0,3), rep(100.0,3)), tnc)
    # so we will fix the labels
    pfu <- rownames(tnc)
    pfu <- sub('^X', '', pfu)
    pfu <- sub('pfu.*', '', pfu)
    pfu <- sub('wt.*', '0.0', pfu)
    pfu <- as.numeric(pfu)
    tnc <- cbind(pfu=pfu, tnc)
    tnc <- as.data.frame( tnc )		# just in case

    # select only counts of sigfigicantly altered genes:
    sig.tc <- cbind(pfu=tnc[ ,1], tnc[ , colnames(tnc) %in% colnames(dat)] )
    tc <- sig.tc



    # working with log2FC is difficult: it fails in many cases
    # it is better to jump ahead and use 'tc' the corrected, filtered
    # tri-sample counts.
    dat.cor <- cor(dat, use="pairwise.complete.obs")
    corrplot(dat.cor, order='hclust', tl.col="black")	
    # the correlation plot should show if there is structure

    dat.fa.paral <- fa.parallel(x=dat.cor, fm="minres", fa="fa") #use pseudo-inverse
    print(dat.fa.paral)
    plot(dat.fa.paral)
    # this should show a recommended number of factors if it worked
    dat.scree <- nScree(x=dat.cor, model="factors")
    plot(dat.scree)

    dat.efa       <- fa(dat)		# nfactors defaults to 1 (see help for meaning)
    dat.efa.6.u   <- fa(dat, nfactors=6, fm='uls')    # does not converge
    dat.efa.6.m   <- fa(dat, nfactors=6, fm='minres') # does not converge
    dat.efa.6.mvt <- fa(dat, nfactors=6, fm='minres',
                   rotate='varimax', scores='tenBerge')  # results are suspect
    dat.efa.6.fvt <- fa(dat, nfactors=6, fm='fa',
                   rotate='varimax', scores='tenBerge')  # results are suspect
    dat.efa.6.mqt <- fa(dat, nfactors=6, fm='minres',
                   rotate='quartimax', scores='tenBerge')# suspect
    dat.efa.6.mbt <- fa(dat, nfactors=6, fm='minres',
                   rotate='bentlerT', scores='tenBerge') # singular
    dat.efa.6.wbt <- fa(dat, nfactors=6, fm='wls',
                   rotate='bentlerT', scores='tenBerge') # singular
    #
    # with correlation matrix (should be the same)
    #
    dat.fa <- fa(r=dat.cor, nfactors=6)					
    # this may need several attempts to get it to converge
    # (it may fail with lack of convergence after 1000 iterations)
    # we may still use it (but should not trust it)
    dat.fa.6.m <- fa(r=dat.cor, nfactors=6, fm="minres")
    # faster, does not get confidence intervals:
    dat.fac.6.mvt <- fac(r=dat.cor, nfactors=6, 
                fm="minres", rotate='varimax', scores='tenBerge') #suspect
    dat.fac <- dat.fac.6.mvt
    # singular, says factors are exactly uncorrelated and that it 
    # switches rotation to 'promax'
    dat.fa.6.minres <- fa(r=dat.cor, fa='fa', nfactors=6, fm="minres") # singular
    # works
    dat.fa.6.minres.varimax <- fa(r=dat.cor, nfactors=6, fm = "minres", rotate='varimax')
    # works
    dat.fa.6.minres.bentlerQ <- fa(r=dat.cor, nfactors=6, fm = "minres", rotate='bentlerQ')
    # fm=uls, ml, and pa, and wls all fail, ols is too slow
    
    # using 4 factors does not give major problems
    dat.fa.nf4   <- fa(r=dat.cor, nfactors=4)
    dat.fa.nf4.m <- fa(r=dat.cor, nfactors=4, fm="minres")
    
    fa.plot(dat.fa)
    fa.plot(dat.fac)
    fa.diagram(dat.fa)
    fa.diagram(dat.fac)


    tc.cor <- cor(tc, use="pairwise.complete.obs")
    corrplot(tc.cor, order='hclust', tl.col="black")	
    # the correlation plot should show if there is structure

    tc.fa.paral <- fa.parallel(x=tc.cor, fm="minres", fa="fa")
    print(tc.fa.paral)
    plot(tc.fa.paral)
    vss(tc)
    # this should show a recommended number of factors
    tc.scree <- nScree(x=tc.cor, model="factors")
    plot(tc.scree)

    tc.fa <- fa(r=tc.cor, nfactors=6)
    # this may need several attempts to get it to converge (diff. random seeds)
    # (it may fail with lack of convergence after 1000 iterations)
    tc.fa <- fa(r=tc.cor, nfactors=6, fm="minres")
    # this works well
    tc.fa <- fa(r=tc.cor, nfactors=6, 
                fm="minres", rotate='varimax', scores='tenBerge')
    # faster, does not get confidence intervals:
    tc.fac <- fac(r=tc.cor, nfactors=6, 
                fm="minres", rotate='varimax', scores='tenBerge')
    # I tried other factoring methods (minres, uls, ols, pa, fa, ml,...), 
    # rotations (varimax, quartimax, bentlerT, onlimin, ...) and 
    # scores (regression, tenBegre, Barlett, ...) without better results.
    # Some simply do not run, fail or take excessively long.

    fa.plot(tc.fa)
    fa.plot(tc.fac)

    fa.graph(tc.fa)
    fa.graph(tc.fac)

    fa.diagram(tc.fa)
    fa.diagram(tc.fac)

    # use a hierarchical clustering solution to find omega
    iclust(tc)
    omega(tc)
    bassAkward(tc)

    # find alpha as an estimate of reliability
    alpha(tc)

}


# 
{
    library(psych)

    cor.dat <- cor(dat[, -1], use="pairwise.complete.obs")
    cor.dat.zero<- cor(clfc[, -1], use="pairwise.complete.obs")
    cor.dat.std <- cor(dat[, -1], use="pairwise.complete.obs")

   # get parallel analysis scree plots
    fa.parallel(x=cor.dat, fm="minres", fa="fa")
    
    library(nfactors)
    nScree(x=cor.dat, model="factors")
    plot(nScree(x=cor.dat,model="factors"))

    # these take like almost forever, do not use
    efa.res <- fa(r=cor.dat, nfactors=10, rotate="oblimin", fm="pa")
    efa.res <- fa(r=cor.dat.zero, nfactors=10, rotate="oblimin", fm="pa")
    efa.res <- fa(r=cor.dat.std, nfactors=10, rotate="oblimin", fm="pa")

    # use these instead
    library(psych)

    # calculate correlation matrix
    dat.cor <- cor(dat, use="pairwise.complete.obs")
    corrplot(dat.cor, order='hclust', tl.col="black")	
    # the correlation plot should show if there is structure

    # do parallel FA and simulated runs to estimate number of factors
    dat.fa.paral <- fa.parallel(x=dat.cor, fm="minres", fa="fa")
    print(dat.fa.paral)
    # this should show a recommended number of factors
    dat.scree <- nScree(x=dat.cor, model="factors")
    plot(dat.scree)

    # do the actual EFA analysis
    #dat.fa <- fa(r=dat.cor, nfactors=6)
    # the above may need several attempts to get it to converge
    # (it may fail with lack of convergence after 1000 iterations)
    # these seem to work better
    dat.fa <- fa(r=dat.cor, nfactors=6, fm="minres") #does not converge
    dat.fac <- fa(r=dat.cor, nfactors=6, 
                fm="minres", rotate='varimax', scores='tenBerge') #suspect


    tc.cor <- cor(tc, use="pairwise.complete.obs")
    corrplot(tc.cor, order='hclust', tl.col="black")	
    # the correlation plot should show if there is structure

    tc.fa.paral <- fa.parallel(x=tc.cor, fm="minres", fa="fa")
    print(tc.fa.paral)
    # this should show a recommended number of factors
    tc.scree <- nScree(x=tc.cor, model="factors")
    plot(tc.scree)

    tc.fa <- fa(r=tc.cor, nfactors=6)
    # this may need several attempts to get it to converge
    # (it may fail with lack of convergence after 1000 iterations)
    tc.fa <- fa(r=tc.cor, nfactors=6, fm="minres")
    tc.fac <- fa(r=tc.cor, nfactors=6, 
                fm="minres", rotate='varimax', scores='tenBerge') #works

}

#
## F I N A L    E F A     R E S U L T S
dir.create('efa', showWarning=FALSE)

tc.cor <- cor(tc, use="pairwise.complete.obs")
png("efa/tc_corplot.png", width = 800, height = 600)
corrplot(tc.cor, order='hclust', tl.col="black") #the plot is wrong
dev.off()

tc.fa.paral <- fa.parallel(x=tc.cor, fm="minres", fa="fa")
print(tc.fa.paral)

# nFctors = 6
tc.fac <- fa(r=tc.cor, nfactors=6, 
             fm="minres", rotate='varimax', scores='tenBerge') #works

sink('efa/tc_fac_6.txt')
print(tc.fac)
sink()

png("efa/tc_fac_6_plot.png", width = 800, height = 600)
fa.plot(tc.fac)
dev.off()

png("efa/tc_fac_6_diagram.png", width = 800, height = 600)
fa.diagram(tc.fac)
dev.off()

# nFactors = 4
tc.fac <- fa(r=tc.cor, nfactors=4, 
             fm="minres", rotate='varimax', scores='tenBerge') #works


write.table(tc.fac, file='efa/tc_fac_4.txt') #cannot coerce class c(psych,fa) to a data.frame

sink('efa/tc_fac_4.txt')
print(tc.fac)
sink()

png("efa/tc_fac_4_plot.png", width = 800, height = 600)
fa.plot(tc.fac)
dev.off()

png("efa/tc_fac_4_diagram.png", width = 800, height = 600)
fa.diagram(tc.fac)
dev.off()

##
# ANNOTATE EFA RESULTS
sink('efa/tc_fac_4_graph.txt')
print(fa.graph(tc.fac))
sink()

datos <- readLines('efa/tc_fac_4_graph.txt')

genes_por_factor <- list()

resultados <- vector("list", length(datos))

for (i in seq_along(datos)){
	linea <- datos[i]
	if (grepl("->", linea)){
    	factor_variable <- strsplit(linea, "->")[[1]]
    	factor <- trimws(factor_variable[1])
    	variable <- trimws(factor_variable[2])
        
        num_variable <- gsub("([V]\\d+)\\s.*", "\\1", variable)
        for (otra_linea in datos) {
        	if (startsWith (linea, num_variable)){
            	gene <- gsub(".*label = \"(ENSC.*?)\".*", "\\1", otra_linea)                     
            }
        }
        resultados[[i]] <- c(linea, gene)
           #     if (!factor %in% names(genes_por_factor)) {
           #         genes_por_factor[[factor]] <- list(gene)
           #    } else {
           #         genes_por_factor[[factor]] <- c(genes_por_factor[[factor]], gene)
           #     } 
           # }
        }
     }
     
df <- as.data.frame(do.call(rbind, resultados))
colnames(df) <- c("efa"  , "gene")
     
